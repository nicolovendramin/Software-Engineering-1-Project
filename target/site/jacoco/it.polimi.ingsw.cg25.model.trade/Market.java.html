<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Market.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">cg25</a> &gt; <a href="index.source.html" class="el_package">it.polimi.ingsw.cg25.model.trade</a> &gt; <span class="el_source">Market.java</span></div><h1>Market.java</h1><pre class="source lang-java linenums">/**
 * 
 */
package it.polimi.ingsw.cg25.model.trade;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import it.polimi.ingsw.cg25.actions.Action;
import it.polimi.ingsw.cg25.actions.BuyingAction;
import it.polimi.ingsw.cg25.actions.ChooseActionTypeAction;
import it.polimi.ingsw.cg25.actions.ErrorAction;
import it.polimi.ingsw.cg25.actions.PassAction;
import it.polimi.ingsw.cg25.actions.SellAssistant;
import it.polimi.ingsw.cg25.actions.SellPermit;
import it.polimi.ingsw.cg25.actions.SellPolitics;
import it.polimi.ingsw.cg25.communication.UnserializedVectorPacket;
import it.polimi.ingsw.cg25.exceptions.CannotPassException;
import it.polimi.ingsw.cg25.exceptions.CannotPerformActionException;
import it.polimi.ingsw.cg25.exceptions.CannotSetupActionException;
import it.polimi.ingsw.cg25.gamegenerics.ActionBasedGame;
import it.polimi.ingsw.cg25.gamegenerics.GameLogger;
import it.polimi.ingsw.cg25.gamegenerics.TurnBasedGame;
import it.polimi.ingsw.cg25.model.MatchCD4;
import it.polimi.ingsw.cg25.model.PlayerCD4;
import it.polimi.ingsw.cg25.proxies.ModelProxy;

/**
 * @author Davide
 *
 */
public class Market implements TurnBasedGame&lt;PlayerCD4&gt;, ActionBasedGame {
	/**
	 * Is the market in the first phase? First phase = selling Second phase =
	 * buying
	 */
	private boolean firstPhase;
	/**
	 * Is the market opened?
	 */
	private boolean open;
	/**
	 * List of on sale {@link Product}
	 */
	private List&lt;Product&lt;? extends Sellable&gt;&gt; onSale;
	/**
	 * List of {@link PlayerCD4} used for market turns
	 */
	private List&lt;PlayerCD4&gt; players;
	/**
	 * Current player index in {@link #players}
	 */
	private int currentPlayerIndex;
	/**
	 * Reference for the {@link MatchCD4}
	 */
	private MatchCD4 match;
	/**
	 * Reference to the {@link ModelProxy}
	 */
	private ModelProxy proxy;
	/**
	 * Counter for round's number
	 */
	private int roundNumber;
	/**
	 * Unique tag for next product (i.d. barcode)
	 */
<span class="fc" id="L70">	private int tag = 0;</span>

	/**
	 * Market constructor
	 * 
	 * @param match
	 *            {@link MatchCD4} the related match
	 * @param proxy
	 *            {@link ModelProxy} the related model proxy
	 */
<span class="fc" id="L80">	public Market(MatchCD4 match, ModelProxy proxy) {</span>
<span class="fc bfc" id="L81" title="All 4 branches covered.">		if(match == null || proxy == null)</span>
<span class="fc" id="L82">			throw new NullPointerException();</span>
<span class="fc" id="L83">		this.match = match;</span>
<span class="fc" id="L84">		this.onSale = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L85">		this.players = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L86">		this.proxy = proxy;</span>
<span class="fc" id="L87">	}</span>

	/**
	 * Get the players
	 * 
	 * @return {@link List} of {@link PlayerCD4}
	 */
	public List&lt;PlayerCD4&gt; getPlayers() {
<span class="fc" id="L95">		return this.players;</span>
	}

	/**
	 * Opens a new market session: &lt;br&gt;
	 * &lt;ul&gt;&lt;li&gt;Set market phase to the first phase&lt;/li&gt;
	 * &lt;li&gt;Gets active players from the match with proper order&lt;/li&gt;
	 * &lt;li&gt;Begin first market's turn&lt;/li&gt;&lt;/ul&gt;
	 */
	public void openMarket() {
<span class="fc" id="L105">		this.open = true;</span>
<span class="fc" id="L106">		this.firstPhase = true;</span>
<span class="fc" id="L107">		this.match.getPlayers().stream().filter(p -&gt; p.isActive()).forEach(this.players::add);</span>
<span class="fc" id="L108">		this.match.getLogger().log(&quot;Market opened&quot;);</span>
<span class="fc" id="L109">		this.setOrder(this.players);</span>
<span class="fc" id="L110">		this.roundNumber = 0;</span>
<span class="fc" id="L111">		this.onSale.clear();</span>
<span class="fc" id="L112">		this.beginTurn();</span>
<span class="fc" id="L113">	}</span>

	/**
	 * Closes a market session&lt;br&gt;&lt;ul&gt;
	 * &lt;li&gt;Gives back to owner unsold products&lt;/li&gt;
	 * &lt;li&gt;Begins the turn of the match&lt;/li&gt;&lt;/ul&gt;
	 */
	public void closeMarket() {
		// Give back unsold products to owner
<span class="fc bfc" id="L122" title="All 2 branches covered.">		for (Product&lt;? extends Sellable&gt; product : this.onSale) {</span>
			// Player is always in the player's list.
<span class="fc" id="L124">			product.achieveProduct(product.getOwner());</span>
		}
<span class="fc" id="L126">		this.onSale.clear();</span>
<span class="fc" id="L127">		this.match.getLogger().log(&quot;Market closed&quot;);</span>
<span class="fc" id="L128">		this.open = false;</span>
		// Checks if the current player in match is still active
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">		if(!this.match.getCurrentPlayer().isActive())</span>
			try {
<span class="nc" id="L132">				this.match.endTurn();</span>
<span class="nc" id="L133">			} catch (CannotPassException e) {</span>
<span class="nc" id="L134">				this.getLogger().log(e,&quot;Passed: first player after closing market is inactive&quot;);</span>
			}
<span class="fc" id="L136">		match.broadCastGameStatus();</span>
<span class="fc" id="L137">		this.match.beginTurn();</span>
<span class="fc" id="L138">	}</span>

	/**
	 * Return the current player
	 * 
	 * @return {@link PlayerCD4} the current player
	 */
	public PlayerCD4 getCurrentPlayer() {
<span class="fc" id="L146">		return this.players.get(this.currentPlayerIndex);</span>
	}

	/**
	 * Begin of player's turn
	 */
	@Override
	public void beginTurn() {
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">		if(!this.isOpen())</span>
<span class="nc" id="L155">			return;</span>
<span class="fc" id="L156">		Action a = new ChooseActionTypeAction&lt;&gt;(this);</span>
		try {
<span class="fc" id="L158">			a.setup();</span>
<span class="pc" id="L159">		} catch (CannotSetupActionException e) {</span>
<span class="nc" id="L160">			this.match.getLogger().log(e, &quot;Something is wrong with the market actions&quot;);</span>
		}
<span class="fc" id="L162">		this.match.broadCastGameStatus();</span>
<span class="fc" id="L163">		this.proxy</span>
<span class="fc" id="L164">				.sendAction(new UnserializedVectorPacket&lt;Action&gt;(a, &quot;Action&quot;, this.getCurrentPlayer().getUserID(), 0));</span>
<span class="fc" id="L165">	}</span>

	/**
	 * End of player's turn Get the next player Calls {@link #endRound()} or
	 * {@link #closeMarket()} if needed
	 * 
	 * @see #nextPlayer()
	 * @see #endRound()
	 * @see #closeMarket()
	 */
	@Override
	public void endTurn() throws CannotPassException {
		// Check canPass isn't really needed in market.
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">		if (!this.canPass())</span>
<span class="nc" id="L179">			throw new CannotPassException();</span>

<span class="fc" id="L181">		PlayerCD4 nextP = this.nextPlayer();</span>

<span class="fc bfc" id="L183" title="All 2 branches covered.">		if (players.indexOf(nextP) &lt; this.currentPlayerIndex) {</span>
			// NB: endRound() takes care of phases and closes market if needed
<span class="fc" id="L185">			this.endRound();</span>
			// NextPlayer may be changed by this.setOrded() called in
			// this.endRound()
<span class="fc" id="L188">			nextP = this.nextPlayer();</span>
<span class="fc" id="L189">			this.setCurrentPlayer(nextP);</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">		} else if (players.indexOf(nextP) == this.currentPlayerIndex) {</span>
			// Only one player is still active
<span class="nc" id="L192">			this.closeMarket();</span>
<span class="nc" id="L193">		} else {</span>
<span class="fc" id="L194">			this.setCurrentPlayer(nextP);</span>
		}
<span class="fc" id="L196">	}</span>

	/**
	 * Set the current player
	 * 
	 * @param player
	 *            {@link PlayerCD4} the player that will be set to current
	 */
	private void setCurrentPlayer(PlayerCD4 player) {
<span class="fc" id="L205">		this.currentPlayerIndex = this.players.indexOf(player);</span>
<span class="fc" id="L206">	}</span>

	/**
	 * Return the next player
	 * 
	 * @return {@link PlayerCD4} the next player
	 */
	@Override
	public PlayerCD4 nextPlayer() {
		PlayerCD4 p;
<span class="fc bfc" id="L216" title="All 2 branches covered.">		for (int index = this.currentPlayerIndex + 1; index != this.currentPlayerIndex; index = (index + 1)</span>
<span class="fc" id="L217">				% this.players.size()) {</span>
<span class="fc" id="L218">			p = this.players.get(index % this.players.size());</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">			if (p.isActive())</span>
<span class="fc" id="L220">				return p;</span>
		}
		// If no Market players are still active close the Market.
		// Don't end the whole game: some inactive players in the match
		// (not doing trading) may have become active now.
<span class="fc" id="L225">		this.closeMarket();</span>
<span class="fc" id="L226">		return null;</span>

	}

	// Used in the actions
	@Override
	public boolean canPass() {
<span class="fc" id="L233">		return true;</span>
	}

	// UnUsed
	@Override
	public boolean hasWon() {
<span class="fc" id="L239">		return false;</span>
	}

	@Override
	public int getRoundNumber() {
<span class="fc" id="L244">		return this.roundNumber;</span>
	}

	/**
	 * Set the proper order of players&lt;br&gt;
	 * First phase: same as match order&lt;br&gt;
	 * Second phase: random order
	 */
	@Override
	public void setOrder(List&lt;PlayerCD4&gt; order) {
<span class="fc bfc" id="L254" title="All 2 branches covered.">		if (this.firstPhase) {</span>
			// Every *active* player (upon match's order) can sale some product
<span class="fc" id="L256">			this.players.clear();</span>
<span class="fc" id="L257">			this.match.getPlayers().stream().filter(p -&gt; p.isActive()).forEach(this.players::add);</span>
<span class="fc" id="L258">		} else {</span>
			// Every player (random order) can buy some product
<span class="fc" id="L260">			Collections.shuffle(order, this.match.getRandom());</span>
		}
<span class="fc" id="L262">	}</span>

	/**
	 * Close a round of the market:&lt;br&gt;
	 * Changes market phase sets the proper order of players 
	 * and increments the round counter
	 */
	@Override
	public void endRound() {
<span class="fc" id="L271">		this.roundNumber++;</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">		if (this.roundNumber &gt; 1)</span>
<span class="fc" id="L273">			this.closeMarket();</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">		this.firstPhase = !this.firstPhase;</span>
<span class="fc" id="L275">		this.setOrder(this.players);</span>
<span class="fc" id="L276">	}</span>

	/**
	 * Add a product to the on sale list
	 * 
	 * @param product
	 *            {@link Product} the product to add
	 */
	public void addProduct(Product&lt;? extends Sellable&gt; product) {
<span class="fc bfc" id="L285" title="All 2 branches covered.">		if(product == null)</span>
<span class="fc" id="L286">			throw new NullPointerException(&quot;Null product reference&quot;);</span>
<span class="fc" id="L287">		this.onSale.add(product);</span>
<span class="fc" id="L288">	}</span>

	/**
	 * Remove a product to the on sale list
	 * 
	 * @param product
	 *            {@link Product} the product to remove
	 */
	public void removeProduct(Product&lt;?&gt; product) {
<span class="fc" id="L297">		this.onSale.remove(product);</span>
<span class="fc" id="L298">	}</span>

	@Override
	public List&lt;Action&gt; getAvailableActions() {
<span class="fc" id="L302">		List&lt;Action&gt; temp = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">		if (firstPhase) {</span>
<span class="fc" id="L304">			temp.add(new SellPermit(this));</span>
<span class="fc" id="L305">			temp.add(new SellPolitics(this));</span>
<span class="fc" id="L306">			temp.add(new SellAssistant(this));</span>
<span class="fc" id="L307">		} else</span>
<span class="nc" id="L308">			temp.add(new BuyingAction(this));</span>
<span class="fc" id="L309">		temp.add(new PassAction&lt;Market&gt;(this));</span>
<span class="fc" id="L310">		return temp;</span>
	}

	@Override
	public Action getStartingAction() {
<span class="fc" id="L315">		return new ChooseActionTypeAction&lt;Market&gt;(this);</span>
	}

	@Override
	public void receiveAction(Action change) {
<span class="nc bnc" id="L320" title="All 2 branches missed.">		if (!this.open)</span>
<span class="nc" id="L321">			return;</span>
		try {
<span class="nc" id="L323">			PlayerCD4 prevP = this.getCurrentPlayer();</span>
<span class="nc" id="L324">			int prevRound = this.roundNumber;</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">			if(change.isAborted())</span>
			{
<span class="nc" id="L327">				Action action = this.getStartingAction();</span>
<span class="nc" id="L328">				action.setup();</span>
<span class="nc" id="L329">				this.proxy.sendAction(new UnserializedVectorPacket&lt;Action&gt;(action, &quot;Action&quot;,</span>
<span class="nc" id="L330">						this.getCurrentPlayer().getUserID(), 0));</span>
<span class="nc" id="L331">				return;</span>
			}
<span class="nc" id="L333">			Action returned = change.doAction();</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">			if (!this.open)</span>
<span class="nc" id="L335">				return;</span>
<span class="nc bnc" id="L336" title="All 4 branches missed.">			if (prevP != this.getCurrentPlayer() &amp;&amp; this.roundNumber == prevRound) {</span>
<span class="nc" id="L337">				this.beginTurn();</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">			} else if (this.roundNumber != prevRound) {</span>
<span class="nc" id="L339">				this.beginTurn();</span>
<span class="nc" id="L340">			} else {</span>
<span class="nc" id="L341">				this.match.informPlayer(getCurrentPlayer());</span>
<span class="nc" id="L342">				returned.setup();</span>
<span class="nc" id="L343">				this.proxy.sendAction(new UnserializedVectorPacket&lt;Action&gt;(returned, &quot;Action&quot;,</span>
<span class="nc" id="L344">						this.getCurrentPlayer().getUserID(), 0));</span>
			}
<span class="nc" id="L346">		} catch (CannotPerformActionException e) {</span>
<span class="nc" id="L347">			this.getLogger().log(e, &quot;There has been an error executing the requested action&quot;);</span>
<span class="nc" id="L348">			ErrorAction&lt;Market&gt; a = new ErrorAction&lt;&gt;(this);</span>
			try {
<span class="nc" id="L350">				a.setup(e.getMessage());</span>
<span class="nc" id="L351">			} catch (Exception e1) {</span>
<span class="nc" id="L352">				this.getLogger().log(e1, &quot;There was an error setting un the ErrorAction&quot;);</span>
<span class="nc" id="L353">				a.setup(&quot;Some error occurred&quot;);</span>
			}
<span class="nc" id="L355">			this.proxy.sendAction(</span>
<span class="nc" id="L356">					new UnserializedVectorPacket&lt;Action&gt;(a, &quot;Action&quot;, this.getCurrentPlayer().getUserID(), 0));</span>
<span class="nc" id="L357">		} catch (CannotSetupActionException e) {</span>
<span class="nc" id="L358">			this.getLogger().log(e, &quot;Couldn't setup the action&quot;);</span>
<span class="nc" id="L359">			ChooseActionTypeAction&lt;Market&gt; a = new ChooseActionTypeAction&lt;&gt;(this);</span>
<span class="nc" id="L360">			this.proxy.sendAction(</span>
<span class="nc" id="L361">					new UnserializedVectorPacket&lt;Action&gt;(a, &quot;Action&quot;, this.getCurrentPlayer().getUserID(), 0));</span>
		}

<span class="nc" id="L364">	}</span>

	/**
	 * Get the next product's available tag
	 * &lt;br&gt; &lt;b&gt;MUST&lt;/b&gt; be called when creating a new product
	 * @return int the tag to use
	 * @see #tag
	 */
	public int getNextProductTag() {
<span class="fc" id="L373">		this.tag = this.tag + 1;</span>
<span class="fc" id="L374">		return tag - 1;</span>
	}

	/**
	 * Return the Match's Game Logger
	 * 
	 * @return {@link GameLogger} Match's Game Logger
	 */
	@Override
	public GameLogger getLogger() {
<span class="fc" id="L384">		return this.match.getLogger();</span>
	}

	/**
	 * Checks the market's status
	 * 
	 * @return boolean true if market is open
	 */
	public boolean isOpen() {
<span class="fc" id="L393">		return this.open;</span>
	}

	/**
	 * Return on sale products
	 * 
	 * @return {@link List} of {@link Product} on sale products
	 */
	public List&lt;Product&lt;? extends Sellable&gt;&gt; getProducts() {
<span class="fc" id="L402">		return onSale;</span>
	}

	/**
	 * Return the phase of the market
	 * @return true if in first phase, false if in second phase
	 */
	public boolean getPhase() {
<span class="fc" id="L410">		return firstPhase;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>